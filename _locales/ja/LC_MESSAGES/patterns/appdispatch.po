# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2010 Pallets
# This file is distributed under the same license as the Flask package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Flask 2.2.x\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-26 22:21+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.10.3\n"

# f77f35becfde412f894643ddc2e8055c
#: ../../flask/docs/patterns/appdispatch.rst:2
msgid "Application Dispatching"
msgstr "アプリケーションの振り分け（Application Dispatching）"

# 983396e6e0f04af38d39485859219281
#: ../../flask/docs/patterns/appdispatch.rst:4
msgid ""
"Application dispatching is the process of combining multiple Flask "
"applications on the WSGI level.  You can combine not only Flask "
"applications but any WSGI application.  This would allow you to run a "
"Django and a Flask application in the same interpreter side by side if "
"you want.  The usefulness of this depends on how the applications work "
"internally."
msgstr ""
"アプリケーションの振り分けは、WSGIレベルで複数のFlaskアプリケーションを"
"併合するプロセスです。Flaskアプリケーションだけでなく、どんなWSGI"
"アプリケーションでも併合できます。これは、もし望むならば、DjangoとFlask"
"のアプリケーションを同じインタープリタで横並びに走らせることを可能に"
"します。このことの有益性は、内部的なアプリケーションの動き方に依存"
"します。"

# 310d603dd5f34cd2a2a63a8ae121da57
#: ../../flask/docs/patterns/appdispatch.rst:11
msgid ""
"The fundamental difference from :doc:`packages` is that in this case you "
"are running the same or different Flask applications that are entirely "
"isolated from each other. They run different configurations and are "
"dispatched on the WSGI level."
msgstr ""
":doc:`packages` との根本的な違いは、こちらのケースでは同一または異なる"
"Flaskアプリケーションをお互いから全く分離して走らせていることです。それらは"
"異なる設定で走り、WSGIのレベルで振り分けられます（dispatched）。"

# dfcabfad8e2042c0abee68cc5ecf5f36
#: ../../flask/docs/patterns/appdispatch.rst:18
msgid "Working with this Document"
msgstr "このドキュメントでの作業（Working with this Document）"

# d6db1262615441ef88aa1147bd866e50
#: ../../flask/docs/patterns/appdispatch.rst:20
msgid ""
"Each of the techniques and examples below results in an ``application`` "
"object that can be run with any WSGI server. For production, see "
":doc:`/deploying/index`. For development, Werkzeug provides a server "
"through :func:`werkzeug.serving.run_simple`::"
msgstr ""
"以下に示す技法と例は、それぞれどんなWSGIサーバでも走らせることが可能な "
"``application`` オブジェクトをもたらします。本番環境用には、:doc:"
"`/deploying/index` を確認してください。開発用には、Werkzeugは :func:"
"`werkzeug.serving.run_simple` で利用可能な開発用の組込みサーバを提供して"
"います::"

# 6ca86a918fd24079821418b05cb91d9d
#: ../../flask/docs/patterns/appdispatch.rst:28
msgid ""
"Note that :func:`run_simple <werkzeug.serving.run_simple>` is not "
"intended for use in production.  Use a production WSGI server. See "
":doc:`/deploying/index`."
msgstr ""
":func:`run_simple <werkzeug.serving.run_simple>` は本番環境で使用する"
"ためにのものではないことに注意してください。（本番環境では）成熟した"
"WSGIサーバ（production WSGI server）を使用してください。:doc:"
"`/deploying/index` を見てください。"

# 14ea9bce361242a68c5ff4fd9dc3e7d4
#: ../../flask/docs/patterns/appdispatch.rst:31
msgid ""
"In order to use the interactive debugger, debugging must be enabled both "
"on the application and the simple server. Here is the \"hello world\" "
"example with debugging and :func:`run_simple "
"<werkzeug.serving.run_simple>`::"
msgstr ""
"インタラクティブなデバッガを使用するためには、アプリケーションとsimple "
"serverの両方でデバッグ機能（debugging）が有効になっている必要があります。"
"以下は、デバッグ機能と :func:`run_simple <werkzeug.serving.run_simple>` を"
"使った「hello world」の例です::"

# 3739c7668cf64f76a1b563ca00542b98
#: ../../flask/docs/patterns/appdispatch.rst:51
msgid "Combining Applications"
msgstr "アプリケーションの併合（Combining Applications）"

# c3412cbaa97f43a98dd2f0af50f989eb
#: ../../flask/docs/patterns/appdispatch.rst:53
msgid ""
"If you have entirely separated applications and you want them to work "
"next to each other in the same Python interpreter process you can take "
"advantage of the :class:`werkzeug.wsgi.DispatcherMiddleware`.  The idea "
"here is that each Flask application is a valid WSGI application and they "
"are combined by the dispatcher middleware into a larger one that is "
"dispatched based on prefix."
msgstr ""
"もしも全く分かれたアプリケーションがあって、それらを同じPythonの"
"インタープリタのプロセスで隣同士で動かしたい場合には、:class:"
"`werkzeug.middleware.dispatcher.DispatcherMiddleware` を活用できます。"
"そのときの考え方は、Flaskアプリケーションはそれぞれ正当なWSGIアプリ"
"ケーションであり、それらはより大きなアプリケーションへdispatcher "
"middlewareによって併合され、（URLのパスの）先頭部分（prefix）に"
"基づいて振り分けられるというものです。"

# de89a7ce5a67449eb8541ee0539b41e9
#: ../../flask/docs/patterns/appdispatch.rst:60
msgid ""
"For example you could have your main application run on ``/`` and your "
"backend interface on ``/backend``::"
msgstr ""
"例えば、メインのアプリケーションを ``/`` で走らせ、バックエンドの"
"インタフェースを ``/backend`` で走らせることができます::"

# 727cc95b142f4f60af6d7a559e852193
#: ../../flask/docs/patterns/appdispatch.rst:73
msgid "Dispatch by Subdomain"
msgstr "サブドメインによる振り分け"

# 46b331d810dc462a928fc562bd541b9e
#: ../../flask/docs/patterns/appdispatch.rst:75
msgid ""
"Sometimes you might want to use multiple instances of the same "
"application with different configurations.  Assuming the application is "
"created inside a function and you can call that function to instantiate "
"it, that is really easy to implement.  In order to develop your "
"application to support creating new instances in functions have a look at"
" the :doc:`appfactories` pattern."
msgstr ""
"ときには、同じアプリケーションの複数のインスタンスを違う設定で使いたい"
"かもしれません。アプリケーションが関数の内側で作られ、アプリケーションを"
"初期化するためにその関数を呼び出せると仮定したとき、それを実装するのは"
"とても容易です。関数の中での新しいインスタンスの作成をサポートするアプリ"
"ケーションを開発するには、:doc:`appfactories` パターンを確認してください。"

# 38373cc4de44498e8d3ef34d32a6b80f
#: ../../flask/docs/patterns/appdispatch.rst:82
msgid ""
"A very common example would be creating applications per subdomain.  For "
"instance you configure your webserver to dispatch all requests for all "
"subdomains to your application and you then use the subdomain information"
" to create user-specific instances.  Once you have your server set up to "
"listen on all subdomains you can use a very simple WSGI application to do"
" the dynamic application creation."
msgstr ""
"とてもありがちな例は、アプリケーションをサブドメインごとに作成すること"
"でしょう。例えば、全てのサブドメインへの全てのリクエストを自分のアプリ"
"ケーションへ振り分けるようにwebサーバを設定し、それからサブドメインの"
"情報を使用してユーザ固有のインスタンスを作成します。全てのサブドメインを"
"受信するように一度サーバを準備（set up）すれば、動的なアプリケーション"
"作成をするとてもシンプルなWSGIアプリケーションを使用できます。"

# dc151dc909e04f7fa4f0bf0f0cc8babf
#: ../../flask/docs/patterns/appdispatch.rst:89
msgid ""
"The perfect level for abstraction in that regard is the WSGI layer.  You "
"write your own WSGI application that looks at the request that comes and "
"delegates it to your Flask application.  If that application does not "
"exist yet, it is dynamically created and remembered::"
msgstr ""
"この観点での抽象化の完璧なレベルは、WSGIの階層です。（以下の例では）受信"
"するリクエストを調べ、そしてリクエストをFlaskアプリケーションへ移譲する、"
"独自のWSGIアプリケーションを自分で作ります。もしもそのアプリケーションが"
"まだ存在しない場合、それは動的に作成され記憶されます::"

# 578f7473e86341d5bc608d94e58b32bc
#: ../../flask/docs/patterns/appdispatch.rst:120
msgid "This dispatcher can then be used like this::"
msgstr "そして、この振り分け機能（dispatcher）は、以下のように使用できます::"

# e5d133f87e96426d93c682e4d1981623
#: ../../flask/docs/patterns/appdispatch.rst:142
msgid "Dispatch by Path"
msgstr "パスによる振り分け（Dispatch by Path）"

# d707172dcc024e5ea710b703ac3cd769
#: ../../flask/docs/patterns/appdispatch.rst:144
msgid ""
"Dispatching by a path on the URL is very similar.  Instead of looking at "
"the ``Host`` header to figure out the subdomain one simply looks at the "
"request path up to the first slash::"
msgstr ""
"URLのパスによる振り分けは非常に似ています。サブドメインを理解するために "
"``Host`` ヘッダを調べる代わりに、シンプルにリクエストのパスを最初の"
"スラッシュまで調べます::"

# db5b2d63bd46495fbd0c8ee3e7a6dafb
#: ../../flask/docs/patterns/appdispatch.rst:176
msgid ""
"The big difference between this and the subdomain one is that this one "
"falls back to another application if the creator function returns "
"``None``::"
msgstr ""
"これとサブドメインのものとの大きな違いは、こちらは、もしもアプリケーション"
"作成関数が ``None`` を返したときは、別のアプリケーションで代わりに対応"
"（fall back）することです（訳注: 上述のコード例の ``__call__`` 内部で、"
"``if app is not None: ... else:`` の後に ``app = self.default_app`` として"
"いる箇所が該当します）::"
